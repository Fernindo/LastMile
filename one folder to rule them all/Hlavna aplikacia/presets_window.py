import os
import json
import tkinter as tk
import tkinter.ttk as ttk
import ttkbootstrap as tb
from tkinter import messagebox, simpledialog

# Reuse your existing app pieces
from basket import Basket                           # :contentReference[oaicite:0]{index=0}
from gui_functions import (                         # :contentReference[oaicite:1]{index=1}
    get_database_connection,
    apply_filters,
    add_to_basket_full,
    recompute_total_spolu,
)
from helpers import create_filter_panel             # :contentReference[oaicite:2]{index=2}


LOGIN_CONFIG_FILE = os.path.join(os.path.dirname(__file__), "login_config.json")


def _load_logged_in_user_id(conn, db_type: str) -> int | None:
    """
    Try to read user id from login_config.json -> users table.
    Falls back to asking user for a numeric id if not found.
    """
    # 1) read login_config.json
    try:
        with open(LOGIN_CONFIG_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        u = (data or {}).get("user") or {}
        username = (u.get("username") or "").strip()
        uid = u.get("id")
    except Exception:
        username, uid = "", None

    cur = conn.cursor()
    # Prefer explicit id if present and valid
    if isinstance(uid, int):
        try:
            sql = "SELECT 1 FROM users WHERE id = %s" if db_type == "postgres" else \
                  "SELECT 1 FROM users WHERE id = ?"
            cur.execute(sql, (uid,))
            if cur.fetchone():
                return uid
        except Exception:
            pass

    # Resolve by username if present
    if username:
        try:
            sql = "SELECT id FROM users WHERE username = %s LIMIT 1" if db_type == "postgres" else \
                  "SELECT id FROM users WHERE username = ? LIMIT 1"
            cur.execute(sql, (username,))
            r = cur.fetchone()
            if r:
                return int(r[0])
        except Exception:
            pass

    # Ask the user as last resort
    try:
        s = simpledialog.askstring("User", "Zadaj svoje user_id (ƒç√≠slo):")
        if s:
            return int(s)
    except Exception:
        pass
    return None


def _ensure_preset_tables(conn, db_type: str):
    cur = conn.cursor()
    if db_type == "postgres":
        # Ensure presets table exists (owner of preset_items)
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS presets (
              id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              name TEXT NOT NULL,
              user_id BIGINT,
              UNIQUE (name, user_id)
            )
            """
        )
        cur.execute("""
        CREATE TABLE IF NOT EXISTS preset_items (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          preset_id  BIGINT NOT NULL REFERENCES presets(id)   ON DELETE CASCADE,
          product_id BIGINT NOT NULL REFERENCES produkty(id)  ON DELETE RESTRICT,
          section_id BIGINT NOT NULL REFERENCES class(id),
          pocet_materialu INTEGER NOT NULL DEFAULT 1,
          pocet_prace     INTEGER NOT NULL DEFAULT 1,
          UNIQUE (preset_id, section_id, product_id)
        )
        """)
        cur.execute("CREATE INDEX IF NOT EXISTS idx_preset_items_preset_section ON preset_items(preset_id, section_id)")
    else:
        # Ensure presets table exists (owner of preset_items)
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS presets (
              id INTEGER PRIMARY KEY,
              name TEXT NOT NULL,
              user_id INTEGER,
              UNIQUE (name, user_id)
            )
            """
        )
        cur.execute("""
        CREATE TABLE IF NOT EXISTS preset_items (
          id INTEGER PRIMARY KEY,
          preset_id  INTEGER NOT NULL,
          product_id INTEGER NOT NULL,
          section_id INTEGER NOT NULL,
          pocet_materialu INTEGER NOT NULL DEFAULT 1,
          pocet_prace     INTEGER NOT NULL DEFAULT 1,
          UNIQUE (preset_id, section_id, product_id),
          FOREIGN KEY (preset_id)  REFERENCES presets(id) ON DELETE CASCADE
        )
        """)
        cur.execute("CREATE INDEX IF NOT EXISTS idx_preset_items_preset_section ON preset_items(preset_id, section_id)")
    conn.commit()


def _fetch_all_presets(cursor, db_type: str):
    ph = "%s" if db_type == "postgres" else "?"
    # Some SQLite DBs may not have COUNT column yet; use correlated subquery for portability
    query = (
        "SELECT p.id, p.name, p.user_id, "
        "(SELECT COUNT(*) FROM preset_items i WHERE i.preset_id = p.id) AS cnt "
        "FROM presets p ORDER BY p.name"
    )
    cursor.execute(query)
    return cursor.fetchall()


def _fetch_preset_items(cursor, db_type: str, preset_id: int):
    ph = "%s" if db_type == "postgres" else "?"
    # Join to resolve product and section names
    query = (
        f"""
        SELECT COALESCE(c.nazov_tabulky, ''), COALESCE(pr.produkt, ''),
               i.pocet_materialu, i.pocet_prace
        FROM preset_items i
        LEFT JOIN produkty pr ON pr.id = i.product_id
        LEFT JOIN class c ON c.id = i.section_id
        WHERE i.preset_id = {ph}
        ORDER BY c.nazov_tabulky NULLS FIRST, pr.produkt
        """
    )
    cursor.execute(query, (preset_id,))
    return cursor.fetchall()


def show_presets_browser(parent=None):
    """Open a simple browser window listing presets and their items."""
    conn, db_type = get_database_connection()
    _ensure_preset_tables(conn, db_type)
    cur = conn.cursor()

    win = tk.Toplevel(parent) if parent else tk.Toplevel()
    win.title("üì¶ Presets Browser")
    try:
        win.transient(parent)
    except Exception:
        try:
            win.transient()
        except Exception:
            pass
    try:
        win.state("zoomed")
    except Exception:
        win.geometry("1000x650")

    # Layout: left list of presets, right items
    win.grid_rowconfigure(0, weight=1)
    win.grid_columnconfigure(0, weight=1)
    win.grid_columnconfigure(1, weight=2)

    left = tb.Frame(win, padding=8)
    left.grid(row=0, column=0, sticky="nsew")

    right = tb.Frame(win, padding=8)
    right.grid(row=0, column=1, sticky="nsew")

    # Presets list
    presets_cols = ("name", "count")
    presets_tree = ttk.Treeview(left, columns=presets_cols, show="headings", selectmode="browse")
    presets_tree.heading("name", text="N√°zov")
    presets_tree.heading("count", text="Polo≈æky")
    presets_tree.column("name", stretch=True, anchor="w")
    presets_tree.column("count", width=80, anchor="center")
    y1 = ttk.Scrollbar(left, orient="vertical", command=presets_tree.yview)
    presets_tree.configure(yscrollcommand=y1.set)
    presets_tree.pack(fill="both", expand=True, side="left")
    y1.pack(side="right", fill="y")

    # Items tree
    item_cols = ("section", "produkt", "pocet_mat", "pocet_pr")
    items_tree = ttk.Treeview(right, columns=item_cols, show="headings", selectmode="extended")
    for c in item_cols:
        items_tree.heading(c, text=c)
        items_tree.column(c, anchor="center")
    items_tree.column("section", anchor="w", width=200)
    items_tree.column("produkt", anchor="w", width=260)
    y2 = ttk.Scrollbar(right, orient="vertical", command=items_tree.yview)
    x2 = ttk.Scrollbar(right, orient="horizontal", command=items_tree.xview)
    items_tree.configure(yscrollcommand=y2.set, xscrollcommand=x2.set)
    items_tree.pack(fill="both", expand=True)
    y2.pack(side="right", fill="y")
    x2.pack(side="bottom", fill="x")

    def load_presets():
        presets_tree.delete(*presets_tree.get_children())
        try:
            rows = _fetch_all_presets(cur, db_type)
        except Exception as e:
            messagebox.showerror("Chyba", str(e), parent=win)
            rows = []
        for (pid, name, user_id, cnt) in rows:
            iid = presets_tree.insert("", "end", values=(name, cnt))
            presets_tree.set(iid, "name", name)
            presets_tree.set(iid, "count", cnt)
            presets_tree.item(iid, tags=(f"id:{pid}",))

    def on_select_pres(_evt=None):
        items_tree.delete(*items_tree.get_children())
        sel = presets_tree.selection()
        if not sel:
            return
        tags = presets_tree.item(sel[0], "tags") or ()
        pid = None
        for t in tags:
            if t.startswith("id:"):
                try:
                    pid = int(t.split(":", 1)[1])
                except Exception:
                    pid = None
                break
        if pid is None:
            return
        try:
            rows = _fetch_preset_items(cur, db_type, pid)
        except Exception as e:
            messagebox.showerror("Chyba", str(e), parent=win)
            rows = []
        for (section, produkt, pm, pp) in rows:
            items_tree.insert("", "end", values=(section or "", produkt or "", pm, pp))

    presets_tree.bind("<<TreeviewSelect>>", on_select_pres)

    # Controls
    btns = tb.Frame(left)
    btns.pack(fill="x", pady=(6, 0))
    tb.Button(btns, text="Obnovi≈•", bootstyle="secondary", command=load_presets).pack(side="left")
    tb.Button(right, text="Zavrie≈•", bootstyle="secondary", command=win.destroy).pack(side="bottom", pady=6)

    load_presets()


def _resolve_product_id(conn, db_type: str, produkt_name: str) -> int | None:
    cur = conn.cursor()
    sql = "SELECT id FROM produkty WHERE produkt = %s LIMIT 1" if db_type == "postgres" else \
          "SELECT id FROM produkty WHERE produkt = ? LIMIT 1"
    cur.execute(sql, (produkt_name,))
    row = cur.fetchone()
    return int(row[0]) if row else None


def _resolve_section_id(conn, db_type: str, section_name: str) -> int | None:
    cur = conn.cursor()
    # Your table is named 'class', display name column 'nazov_tabulky'
    sql = "SELECT id FROM class WHERE nazov_tabulky = %s LIMIT 1" if db_type == "postgres" else \
          "SELECT id FROM class WHERE nazov_tabulky = ? LIMIT 1"
    cur.execute(sql, (section_name,))
    row = cur.fetchone()
    return int(row[0]) if row else None


def _find_or_create_preset(conn, db_type: str, name: str, user_id: int) -> int:
    cur = conn.cursor()
    sql_sel = "SELECT id FROM presets WHERE name = %s AND user_id = %s" if db_type == "postgres" else \
              "SELECT id FROM presets WHERE name = ? AND user_id = ?"
    cur.execute(sql_sel, (name, user_id))
    r = cur.fetchone()
    if r:
        return int(r[0])

    sql_ins = "INSERT INTO presets (name, user_id) VALUES (%s, %s) RETURNING id" if db_type == "postgres" else \
              "INSERT INTO presets (name, user_id) VALUES (?, ?)"
    if db_type == "postgres":
        cur.execute(sql_ins, (name, user_id))
        pid = int(cur.fetchone()[0])
    else:
        cur.execute(sql_ins, (name, user_id))
        cur.execute("SELECT last_insert_rowid()")
        pid = int(cur.fetchone()[0])
    conn.commit()
    return pid


def _save_preset_from_basket(conn, db_type: str, preset_name: str, user_id: int, basket: Basket):
    """
    Map basket -> preset_items via produkt name + section -> IDs.
    """
    _ensure_preset_tables(conn, db_type)
    preset_id = _find_or_create_preset(conn, db_type, preset_name, user_id)

    cur = conn.cursor()
    # Clear existing items for this preset (so saving again overwrites cleanly)
    sql_del = "DELETE FROM preset_items WHERE preset_id = %s" if db_type == "postgres" else \
              "DELETE FROM preset_items WHERE preset_id = ?"
    cur.execute(sql_del, (preset_id,))

    rows = []
    for section_name, products in basket.items.items():
        sid = _resolve_section_id(conn, db_type, section_name) or _resolve_section_id(conn, db_type, "Uncategorized")
        if sid is None:
            # If section not found, try to fallback to any existing section id
            # or create a fake one (for Postgres you'd normally add it; we skip here)
            continue
        for produkt_name, info in products.items():
            pid = _resolve_product_id(conn, db_type, produkt_name)
            if pid is None:
                # Product no longer exists in DB; skip it
                continue
            rows.append((
                preset_id,
                pid,
                sid,
                int(info.pocet_materialu),
                int(info.pocet_prace),
            ))

    if rows:
        ph = ",".join(("%s" if db_type == "postgres" else "?") for _ in range(5))
        sql_ins = f"""
            INSERT INTO preset_items
              (preset_id, product_id, section_id, pocet_materialu, pocet_prace)
            VALUES ({ph})
            """
        cur.executemany(sql_ins, rows)
    conn.commit()
    return preset_id


def show_presets_window():
    """
    Preset Builder: behaves like the normal GUI‚Äôs left DB browser + right basket,
    but the primary action is 'Save as preset'.
    """
    conn, db_type = get_database_connection()
    cursor = conn.cursor()

    # ‚îÄ‚îÄ Window scaffold
    style = tb.Style(theme="litera")
    win = tk.Toplevel()
    if isinstance(win, tk.Toplevel):
        win.transient()
    win.title("üì¶ Preset Builder")
    win.title("üì¶ Preset Builder")
    try:
        win.state("zoomed")
    except Exception:
        try:
            win.geometry("1100x700")
        except Exception:
            pass

    # ‚îÄ‚îÄ Layout: left (DB), right (basket)
    root = win
    root.grid_rowconfigure(0, weight=1)
    root.grid_columnconfigure(0, weight=1)
    root.grid_columnconfigure(1, weight=1)

    # Left panel: DB filter + results
    left = tb.Frame(root, padding=8)
    left.grid(row=0, column=0, sticky="nsew")

    # Right panel: Basket
    right = tb.Frame(root, padding=8)
    right.grid(row=0, column=1, sticky="nsew")

    # ‚îÄ‚îÄ Filters (reuse your helper)
    def refresh_db():
        try:
            apply_filters(cursor, db_type, table_vars, category_vars, name_entry, db_tree)
        except Exception as e:
            messagebox.showerror("Chyba", str(e))

    filter_container, filter_frame, setup_cat_tree, category_vars, table_vars = create_filter_panel(
        left, lambda: refresh_db()
    )
    filter_container.pack(fill="x", padx=6, pady=(0, 6))

    # Build category tree from DB
    category_structure = {}
    try:
        cursor.execute("SELECT id, hlavna_kategoria, nazov_tabulky FROM class")
        for cid, main_cat, tablename in cursor.fetchall():
            category_structure.setdefault(main_cat, []).append((cid, tablename))
    except Exception:
        pass
    setup_cat_tree(category_structure)

    # Search + controls
    top = tb.Frame(left)
    top.pack(fill="x", pady=(6, 6))
    tk.Label(top, text="Vyhƒæad√°vanie:").pack(side="left", padx=(4, 6))
    name_entry = tk.Entry(top, width=32)
    name_entry.pack(side="left")
    name_entry.bind("<KeyRelease>", lambda e: root.after(200, refresh_db))
    tb.Button(top, text="Obnovi≈•", bootstyle="secondary", command=refresh_db).pack(side="left", padx=6)

    # DB results tree
    cols = (
        "produkt", "jednotky", "dodavatel", "odkaz",
        "koeficient_material", "nakup_materialu", "cena_prace", "koeficient_prace"
    )
    db_tree = ttk.Treeview(left, columns=cols, show="headings", selectmode="extended")
    for c in cols:
        db_tree.heading(c, text=c.capitalize())
        db_tree.column(c, anchor="center", stretch=True)
    ysb = ttk.Scrollbar(left, orient="vertical", command=db_tree.yview)
    xsb = ttk.Scrollbar(left, orient="horizontal", command=db_tree.xview)
    db_tree.configure(yscrollcommand=ysb.set, xscrollcommand=xsb.set)
    db_tree.pack(fill="both", expand=True)
    ysb.pack(side="right", fill="y")
    xsb.pack(side="bottom", fill="x")

    # ‚îÄ‚îÄ Basket
    basket = Basket()
    right_top = tb.Frame(right)
    right_top.pack(fill="x")
    total_spolu_var = tk.StringVar(value="Spolu: 0.00 ‚Ç¨")
    total_praca_var = tk.StringVar(value="Spolu pr√°ca: 0.00 ‚Ç¨")
    total_material_var = tk.StringVar(value="Spolu materi√°l: 0.00 ‚Ç¨")

    tk.Label(right_top, textvariable=total_material_var).pack(side="left", padx=6)
    tk.Label(right_top, textvariable=total_praca_var).pack(side="left", padx=12)
    tk.Label(right_top, textvariable=total_spolu_var, font=("Segoe UI", 10, "bold")).pack(side="right", padx=6)

    basket_cols = (
        "produkt","jednotky","pocet_mat","k_mat","nakup_mat",
        "predaj_mat_jedn","nakup_mat_spolu","predaj_mat_spolu","zisk_mat","marza_mat",
        "pocet_pr","k_pr","cena_pr","nakup_pr_spolu","predaj_pr_jedn","predaj_pr_spolu",
        "zisk_pr","marza_pr","predaj_spolu","sync"
    )
    basket_tree = ttk.Treeview(right, columns=basket_cols, show="tree headings", selectmode="extended")
    for c in basket_cols:
        basket_tree.heading(c, text=c)
        basket_tree.column(c, anchor="center", stretch=True)
    ysb2 = ttk.Scrollbar(right, orient="vertical", command=basket_tree.yview)
    xsb2 = ttk.Scrollbar(right, orient="horizontal", command=basket_tree.xview)
    basket_tree.configure(yscrollcommand=ysb2.set, xscrollcommand=xsb2.set)
    basket_tree.pack(fill="both", expand=True, pady=(6, 6))
    ysb2.pack(side="right", fill="y")
    xsb2.pack(side="bottom", fill="x")

    # Add to basket from DB selection
    def add_selected_to_basket():
        sel = db_tree.selection()
        if not sel:
            messagebox.showwarning("V√Ωber", "Najprv vyber polo≈æky v datab√°ze.")
            return

        def mark_modified():
            # nothing special for builder; totals recomputed anyway
            pass

        for iid in sel:
            vals = db_tree.item(iid).get("values")
            if not vals:
                continue
            # values already shaped for add_to_basket_full; inject section from header tag if present
            section = None
            tags = db_tree.item(iid, "tags") or ()
            if "header" in tags:
                continue
            # Your apply_filters puts the section name as the 9th value in tree when building cards,
            # but here we just default to "Uncategorized". User can drag later if needed.
            item = tuple(vals[:8]) + (None,)
            add_to_basket_full(item, basket, conn, cursor, db_type, basket_tree,
                               mark_modified, total_spolu_var, None, total_material_var)
        # Update totals
        recompute_total_spolu(basket, total_spolu_var, None, total_material_var)

    tb.Button(left, text="Prida≈• do ko≈°√≠ka", bootstyle="success", command=add_selected_to_basket).pack(fill="x", pady=(6, 10), padx=2)

    # Initial load
    refresh_db()

    # ‚îÄ‚îÄ Save as preset
    def save_as_preset():
        if not basket.items:
            messagebox.showinfo("Info", "Ko≈°√≠k je pr√°zdny.")
            return

        name = simpledialog.askstring("Preset", "N√°zov presetu:")
        if not (name and name.strip()):
            return

        uid = _load_logged_in_user_id(conn, db_type)
        if uid is None:
            messagebox.showerror("Chyba", "Neviem urƒçi≈• user_id.")
            return

        try:
            pid = _save_preset_from_basket(conn, db_type, name.strip(), uid, basket)
            messagebox.showinfo("OK", f"Preset '{name}' ulo≈æen√Ω (ID {pid}).")
        except Exception as e:
            messagebox.showerror("Chyba", f"Nepodarilo sa ulo≈æi≈• preset:\n{e}")

    btn_bar = tb.Frame(right)
    btn_bar.pack(fill="x")
    tb.Button(btn_bar, text="Ulo≈æi≈• ako preset", bootstyle="primary", command=save_as_preset).pack(side="left", padx=4, pady=4)
    tb.Button(btn_bar, text="Zavrie≈•", bootstyle="secondary", command=win.destroy).pack(side="right", padx=4, pady=4)
