import os
import json
import tkinter as tk
import tkinter.ttk as ttk
import ttkbootstrap as tb
from tkinter import messagebox, simpledialog

# Reuse your existing app pieces
from basket import Basket                           # :contentReference[oaicite:0]{index=0}
from gui_functions import (                         # :contentReference[oaicite:1]{index=1}
    get_database_connection,
    apply_filters,
    add_to_basket_full,
    recompute_total_spolu,
)
from helpers import create_filter_panel, format_currency             # :contentReference[oaicite:2]{index=2}


LOGIN_CONFIG_FILE = os.path.join(os.path.dirname(__file__), "login_config.json")


def _load_logged_in_user_id(conn, db_type: str) -> int | None:
    """
    Try to read user id from login_config.json -> users table.
    Falls back to asking user for a numeric id if not found.
    """
    # 1) read login_config.json
    try:
        with open(LOGIN_CONFIG_FILE, "r", encoding="utf-8") as f:
            data = json.load(f)
        u = (data or {}).get("user") or {}
        username = (u.get("username") or "").strip()
        uid = u.get("id")
    except Exception:
        username, uid = "", None

    cur = conn.cursor()
    # Prefer explicit id if present and valid
    if isinstance(uid, int):
        try:
            sql = "SELECT 1 FROM users WHERE id = %s" if db_type == "postgres" else \
                  "SELECT 1 FROM users WHERE id = ?"
            cur.execute(sql, (uid,))
            if cur.fetchone():
                return uid
        except Exception:
            pass

    # Resolve by username if present
    if username:
        try:
            sql = "SELECT id FROM users WHERE username = %s LIMIT 1" if db_type == "postgres" else \
                  "SELECT id FROM users WHERE username = ? LIMIT 1"
            cur.execute(sql, (username,))
            r = cur.fetchone()
            if r:
                return int(r[0])
        except Exception:
            pass

    # Ask the user as last resort
    try:
        s = simpledialog.askstring("User", "Zadaj svoje user_id (ƒç√≠slo):")
        if s:
            return int(s)
    except Exception:
        pass
    return None


def _ensure_preset_tables(conn, db_type: str):
    cur = conn.cursor()
    if db_type == "postgres":
        # Ensure presets table exists (owner of preset_items)
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS presets (
              id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              name TEXT NOT NULL,
              user_id BIGINT,
              UNIQUE (name, user_id)
            )
            """
        )
        cur.execute("""
        CREATE TABLE IF NOT EXISTS preset_items (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          preset_id  BIGINT NOT NULL REFERENCES presets(id)   ON DELETE CASCADE,
          product_id BIGINT NOT NULL REFERENCES produkty(id)  ON DELETE RESTRICT,
          section_id BIGINT NOT NULL REFERENCES class(id),
          pocet_materialu INTEGER NOT NULL DEFAULT 1,
          pocet_prace     INTEGER NOT NULL DEFAULT 1,
          UNIQUE (preset_id, section_id, product_id)
        )
        """)
        cur.execute("CREATE INDEX IF NOT EXISTS idx_preset_items_preset_section ON preset_items(preset_id, section_id)")
    else:
        # Ensure presets table exists (owner of preset_items)
        cur.execute(
            """
            CREATE TABLE IF NOT EXISTS presets (
              id INTEGER PRIMARY KEY,
              name TEXT NOT NULL,
              user_id INTEGER,
              UNIQUE (name, user_id)
            )
            """
        )
        cur.execute("""
        CREATE TABLE IF NOT EXISTS preset_items (
          id INTEGER PRIMARY KEY,
          preset_id  INTEGER NOT NULL,
          product_id INTEGER NOT NULL,
          section_id INTEGER NOT NULL,
          pocet_materialu INTEGER NOT NULL DEFAULT 1,
          pocet_prace     INTEGER NOT NULL DEFAULT 1,
          UNIQUE (preset_id, section_id, product_id),
          FOREIGN KEY (preset_id)  REFERENCES presets(id) ON DELETE CASCADE
        )
        """)
        cur.execute("CREATE INDEX IF NOT EXISTS idx_preset_items_preset_section ON preset_items(preset_id, section_id)")
    conn.commit()


def _fetch_all_presets(cursor, db_type: str):
    ph = "%s" if db_type == "postgres" else "?"
    # Some SQLite DBs may not have COUNT column yet; use correlated subquery for portability
    query = (
        "SELECT p.id, p.name, p.user_id, "
        "(SELECT COUNT(*) FROM preset_items i WHERE i.preset_id = p.id) AS cnt "
        "FROM presets p ORDER BY p.name"
    )
    cursor.execute(query)
    return cursor.fetchall()


def _fetch_preset_items(cursor, db_type: str, preset_id: int):
    ph = "%s" if db_type == "postgres" else "?"
    # Join to resolve product and section names
    query = (
        f"""
        SELECT COALESCE(c.nazov_tabulky, ''), COALESCE(pr.produkt, ''),
               i.pocet_materialu, i.pocet_prace
        FROM preset_items i
        LEFT JOIN produkty pr ON pr.id = i.product_id
        LEFT JOIN class c ON c.id = i.section_id
        WHERE i.preset_id = {ph}
        ORDER BY c.nazov_tabulky NULLS FIRST, pr.produkt
        """
    )
    cursor.execute(query, (preset_id,))
    return cursor.fetchall()


def show_presets_cards_browser(parent=None, **kwargs):
    """Show presets as cards: name, total price, and a few items.

    Optional kwargs (for integration with the main basket):
    - conn, cursor, db_type
    - basket, basket_tree
    - mark_modified
    - total_spolu_var, total_praca_var, total_material_var
    """
    conn = kwargs.get("conn")
    cur = kwargs.get("cursor")
    db_type = kwargs.get("db_type")
    if not (conn and cur and db_type):
        conn, db_type = get_database_connection()
        cur = conn.cursor()
    _ensure_preset_tables(conn, db_type)

    # Basket integration (may be None)
    basket = kwargs.get("basket")
    basket_tree = kwargs.get("basket_tree")
    mark_modified = kwargs.get("mark_modified") or (lambda: None)
    total_spolu_var = kwargs.get("total_spolu_var")
    total_praca_var = kwargs.get("total_praca_var")
    total_material_var = kwargs.get("total_material_var")

    win = tk.Toplevel(parent) if parent else tk.Toplevel()
    try:
        if parent:
            win.transient(parent)
        else:
            win.transient()
    except Exception:
        pass
    try:
        win.state("zoomed")
    except Exception:
        try:
            win.geometry("1100x700")
        except Exception:
            pass
    win.title("Presety")

    # Scrollable cards container (mirrors DB cards style)
    wrap = tb.Frame(win)
    wrap.pack(fill="both", expand=True)
    canvas = tk.Canvas(wrap, highlightthickness=0)
    vsb = ttk.Scrollbar(wrap, orient="vertical", command=canvas.yview)
    canvas.configure(yscrollcommand=vsb.set)
    vsb.pack(side="right", fill="y")
    canvas.pack(side="left", fill="both", expand=True)
    inner = tb.Frame(canvas)
    _win_id = canvas.create_window((0, 0), window=inner, anchor="nw")

    def _on_inner_configure(_e=None):
        try:
            canvas.configure(scrollregion=canvas.bbox("all"))
        except Exception:
            pass
    inner.bind("<Configure>", _on_inner_configure)

    def _on_canvas_configure(_e=None):
        try:
            current = canvas.itemcget(_win_id, "width")
            w = canvas.winfo_width()
            if not current or abs(int(float(current)) - w) >= 4:
                canvas.itemconfig(_win_id, width=w)
        except Exception:
            pass
    canvas.bind("<Configure>", _on_canvas_configure)

    def _on_wheel(event):
        units = 0
        if getattr(event, "delta", 0):
            try:
                units = int(-1 * (event.delta / 120))
            except Exception:
                units = -1 if event.delta > 0 else 1
            if units == 0:
                units = -1 if event.delta > 0 else 1
        else:
            if getattr(event, "num", None) == 4:
                units = -1
            elif getattr(event, "num", None) == 5:
                units = 1
        if units:
            canvas.yview_scroll(units, "units")
        return "break"

    for w in (canvas, inner, wrap, vsb):
        try:
            w.bind("<MouseWheel>", _on_wheel)
            w.bind("<Button-4>", _on_wheel)
            w.bind("<Button-5>", _on_wheel)
        except Exception:
            pass
    inner.bind("<Enter>", lambda e: canvas.focus_set())
    wrap.bind("<Enter>", lambda e: canvas.focus_set())

    # Helpers
    def compute_preset_total(pid: int) -> float:
        ph = "%s" if db_type == "postgres" else "?"
        sql = (
            "SELECT COALESCE(SUM("
            " p.nakup_materialu * p.koeficient_material * i.pocet_materialu"
            " + p.cena_prace * p.koeficient_prace * i.pocet_prace"
            "), 0)"
            " FROM preset_items i"
            " JOIN produkty p ON p.id = i.product_id"
            f" WHERE i.preset_id = {ph}"
        )
        try:
            cur.execute(sql, (pid,))
            r = cur.fetchone()
            return float(r[0] or 0.0)
        except Exception:
            return 0.0

    def sample_items_text(pid: int, limit: int = 3) -> str:
        try:
            rows = _fetch_preset_items(cur, db_type, pid)
        except Exception:
            rows = []
        names = [str(r[1]) for r in rows if r and r[1]]
        head = names[:limit]
        more = max(0, len(names) - len(head))
        if not head:
            return "(bez polo≈æiek)"
        s = ", ".join(head)
        if more:
            s += f" (+{more} ƒèal≈°ie)"
        return s

    def _fetch_items_full(pid: int):
        """Return rows with full product fields for adding to basket."""
        ph = "%s" if db_type == "postgres" else "?"
        sql = (
            "SELECT COALESCE(c.nazov_tabulky,''), p.produkt, p.jednotky, p.dodavatel, p.odkaz,"
            " p.koeficient_material, p.nakup_materialu, p.cena_prace, p.koeficient_prace,"
            " i.pocet_materialu, i.pocet_prace"
            " FROM preset_items i"
            " JOIN produkty p ON p.id = i.product_id"
            " LEFT JOIN class c ON c.id = i.section_id"
            f" WHERE i.preset_id = {ph}"
            " ORDER BY c.nazov_tabulky NULLS FIRST, p.produkt"
        )
        cur.execute(sql, (pid,))
        return cur.fetchall()

    def _add_preset_to_basket(pid: int):
        if not (basket and basket_tree and total_spolu_var is not None):
            messagebox.showinfo("Info", "Otvoren√© bez ko≈°√≠ka ‚Äì nie je ƒço prida≈•.")
            return
        try:
            rows = _fetch_items_full(pid)
        except Exception as e:
            messagebox.showerror("Chyba", f"Nepodarilo sa naƒç√≠ta≈• polo≈æky presetu:\n{e}")
            return
        from gui_functions import add_to_basket_full, recompute_total_spolu
        changed = False
        for (section, produkt, jednotky, dodavatel, odkaz,
             k_mat, nakup_mat, cena_pr, k_pr, pm, pp) in rows:
            item = (
                produkt, jednotky, dodavatel, odkaz,
                float(k_mat), float(nakup_mat), float(cena_pr), float(k_pr),
                section or None,
            )
            try:
                sec = section or "Uncategorized"
                existed_before = (sec in basket.items and produkt in basket.items[sec])
                add_to_basket_full(
                    item,
                    basket,
                    conn,
                    cur,
                    db_type,
                    basket_tree,
                    mark_modified,
                    total_spolu_var,
                    total_praca_var,
                    total_material_var,
                )
                if sec in basket.items and produkt in basket.items[sec]:
                    bi = basket.items[sec][produkt]
                    # Update counts (increment if already present)
                    if existed_before:
                        bi.pocet_materialu += int(pm)
                        bi.pocet_prace += int(pp)
                    else:
                        bi.pocet_materialu = int(pm)
                        bi.pocet_prace = int(pp)
                        try:
                            basket.original[sec][produkt].pocet_materialu = int(pm)
                            basket.original[sec][produkt].pocet_prace = int(pp)
                        except Exception:
                            pass
                    changed = True
            except Exception as e:
                messagebox.showerror("Chyba", f"Probl√©m pri prid√°van√≠ '{produkt}':\n{e}")
                return
        if changed:
            try:
                basket.update_tree(basket_tree)
                recompute_total_spolu(basket, total_spolu_var, total_praca_var, total_material_var)
                mark_modified()
            except Exception:
                pass

    def _open_preset_detail(pid: int, name: str):
        try:
            rows = _fetch_items_full(pid)
        except Exception as e:
            messagebox.showerror("Chyba", f"Nepodarilo sa naƒç√≠ta≈• polo≈æky presetu:\n{e}")
            return
        win2 = tk.Toplevel(win)
        try:
            win2.transient(win)
        except Exception:
            pass
        win2.title(f"Preset: {name}")
        win2.geometry("900x600")
        cols = ("section", "produkt", "pocet_mat", "pocet_pr")
        tree = ttk.Treeview(win2, columns=cols, show="headings")
        tree.pack(fill="both", expand=True)
        for c in cols:
            tree.heading(c, text=c)
            tree.column(c, anchor="w", stretch=True)
        for (section, produkt, _, _, _, _, _, _, _, pm, pp) in rows:
            tree.insert("", "end", values=(section or "", produkt or "", int(pm), int(pp)))
        bar = tb.Frame(win2)
        bar.pack(fill="x")
        if basket and basket_tree and total_spolu_var is not None:
            tb.Button(bar, text="Prida≈• v≈°etko do ko≈°√≠ka", bootstyle="success",
                      command=lambda: (_add_preset_to_basket(pid), win2.focus_force())).pack(side="left", padx=6, pady=6)
        tb.Button(bar, text="Zavrie≈•", bootstyle="secondary", command=win2.destroy).pack(side="right", padx=6, pady=6)

    def populate_cards():
        for w in inner.winfo_children():
            w.destroy()
        cols = 7
        for i in range(cols):
            try:
                inner.grid_columnconfigure(i, weight=1, uniform="preset_cards")
            except Exception:
                pass
        try:
            rows = _fetch_all_presets(cur, db_type)
        except Exception as e:
            messagebox.showerror("Chyba", str(e), parent=win)
            rows = []

        r = 0
        c = 0
        for (pid, name, _uid, cnt) in rows:
            total = compute_preset_total(pid)
            items_preview = sample_items_text(pid)

            card = tb.Frame(inner, bootstyle="light", padding=10)
            card.grid(row=r, column=c, padx=6, pady=6, sticky="nsew")
            tk.Label(card, text=str(name), font=("Segoe UI", 10, "bold"), anchor="w").pack(fill="x")
            tk.Label(card, text=f"Spolu: {format_currency(total)}", anchor="w").pack(fill="x", pady=(2, 0))
            tk.Label(card, text=f"Polo≈æky: {cnt}", anchor="w").pack(fill="x")
            tk.Label(card, text=items_preview, anchor="w", wraplength=220, justify="left").pack(fill="x", pady=(4, 0))

            # Actions row
            btnrow = tb.Frame(card)
            btnrow.pack(fill="x", pady=(6, 0))
            tb.Button(btnrow, text="ZobraziÔøΩÔøΩ", bootstyle="secondary",
                      command=lambda pid=pid, name=name: _open_preset_detail(pid, name)).pack(side="left")
            if basket and basket_tree and total_spolu_var is not None:
                tb.Button(btnrow, text="PridaÔøΩÔøΩ do koÔøΩÔøΩA-ka", bootstyle="success",
                          command=lambda pid=pid: _add_preset_to_basket(pid)).pack(side="right")

            c += 1
            if c >= cols:
                c = 0
                r += 1

    populate_cards()

    toolbar = tb.Frame(win)
    toolbar.pack(fill="x", side="bottom")
    tb.Button(toolbar, text="Obnovi≈•", bootstyle="secondary", command=populate_cards).pack(side="left", padx=6, pady=6)
    tb.Button(toolbar, text="Zavrie≈•", bootstyle="secondary", command=win.destroy).pack(side="right", padx=6, pady=6)


def show_presets_browser(parent=None):
    """Open a simple browser window listing presets and their items."""
    conn, db_type = get_database_connection()
    _ensure_preset_tables(conn, db_type)
    cur = conn.cursor()

    win = tk.Toplevel(parent) if parent else tk.Toplevel()
    win.title("üì¶ Presets Browser")
    try:
        win.transient(parent)
    except Exception:
        try:
            win.transient()
        except Exception:
            pass
    try:
        win.state("zoomed")
    except Exception:
        win.geometry("1000x650")

    # Layout: left list of presets, right items
    win.grid_rowconfigure(0, weight=1)
    win.grid_columnconfigure(0, weight=1)
    win.grid_columnconfigure(1, weight=2)

    left = tb.Frame(win, padding=8)
    left.grid(row=0, column=0, sticky="nsew")

    right = tb.Frame(win, padding=8)
    right.grid(row=0, column=1, sticky="nsew")

    # Presets list
    presets_cols = ("name", "count")
    presets_tree = ttk.Treeview(left, columns=presets_cols, show="headings", selectmode="browse")
    presets_tree.heading("name", text="N√°zov")
    presets_tree.heading("count", text="Polo≈æky")
    presets_tree.column("name", stretch=True, anchor="w")
    presets_tree.column("count", width=80, anchor="center")
    y1 = ttk.Scrollbar(left, orient="vertical", command=presets_tree.yview)
    presets_tree.configure(yscrollcommand=y1.set)
    presets_tree.pack(fill="both", expand=True, side="left")
    y1.pack(side="right", fill="y")

    # Items tree
    item_cols = ("section", "produkt", "pocet_mat", "pocet_pr")
    items_tree = ttk.Treeview(right, columns=item_cols, show="headings", selectmode="extended")
    for c in item_cols:
        items_tree.heading(c, text=c)
        items_tree.column(c, anchor="center")
    items_tree.column("section", anchor="w", width=200)
    items_tree.column("produkt", anchor="w", width=260)
    y2 = ttk.Scrollbar(right, orient="vertical", command=items_tree.yview)
    x2 = ttk.Scrollbar(right, orient="horizontal", command=items_tree.xview)
    items_tree.configure(yscrollcommand=y2.set, xscrollcommand=x2.set)
    items_tree.pack(fill="both", expand=True)
    y2.pack(side="right", fill="y")
    x2.pack(side="bottom", fill="x")

    def load_presets():
        presets_tree.delete(*presets_tree.get_children())
        try:
            rows = _fetch_all_presets(cur, db_type)
        except Exception as e:
            messagebox.showerror("Chyba", str(e), parent=win)
            rows = []
        for (pid, name, user_id, cnt) in rows:
            iid = presets_tree.insert("", "end", values=(name, cnt))
            presets_tree.set(iid, "name", name)
            presets_tree.set(iid, "count", cnt)
            presets_tree.item(iid, tags=(f"id:{pid}",))

    def on_select_pres(_evt=None):
        items_tree.delete(*items_tree.get_children())
        sel = presets_tree.selection()
        if not sel:
            return
        tags = presets_tree.item(sel[0], "tags") or ()
        pid = None
        for t in tags:
            if t.startswith("id:"):
                try:
                    pid = int(t.split(":", 1)[1])
                except Exception:
                    pid = None
                break
        if pid is None:
            return
        try:
            rows = _fetch_preset_items(cur, db_type, pid)
        except Exception as e:
            messagebox.showerror("Chyba", str(e), parent=win)
            rows = []
        for (section, produkt, pm, pp) in rows:
            items_tree.insert("", "end", values=(section or "", produkt or "", pm, pp))

    presets_tree.bind("<<TreeviewSelect>>", on_select_pres)

    # Controls
    btns = tb.Frame(left)
    btns.pack(fill="x", pady=(6, 0))
    tb.Button(btns, text="Obnovi≈•", bootstyle="secondary", command=load_presets).pack(side="left")
    tb.Button(right, text="Zavrie≈•", bootstyle="secondary", command=win.destroy).pack(side="bottom", pady=6)

    load_presets()


def _resolve_product_id(conn, db_type: str, produkt_name: str) -> int | None:
    cur = conn.cursor()
    sql = "SELECT id FROM produkty WHERE produkt = %s LIMIT 1" if db_type == "postgres" else \
          "SELECT id FROM produkty WHERE produkt = ? LIMIT 1"
    cur.execute(sql, (produkt_name,))
    row = cur.fetchone()
    return int(row[0]) if row else None


def _resolve_section_id(conn, db_type: str, section_name: str) -> int | None:
    cur = conn.cursor()
    # Your table is named 'class', display name column 'nazov_tabulky'
    sql = "SELECT id FROM class WHERE nazov_tabulky = %s LIMIT 1" if db_type == "postgres" else \
          "SELECT id FROM class WHERE nazov_tabulky = ? LIMIT 1"
    cur.execute(sql, (section_name,))
    row = cur.fetchone()
    return int(row[0]) if row else None


def _find_or_create_preset(conn, db_type: str, name: str, user_id: int) -> int:
    cur = conn.cursor()
    sql_sel = "SELECT id FROM presets WHERE name = %s AND user_id = %s" if db_type == "postgres" else \
              "SELECT id FROM presets WHERE name = ? AND user_id = ?"
    cur.execute(sql_sel, (name, user_id))
    r = cur.fetchone()
    if r:
        return int(r[0])

    sql_ins = "INSERT INTO presets (name, user_id) VALUES (%s, %s) RETURNING id" if db_type == "postgres" else \
              "INSERT INTO presets (name, user_id) VALUES (?, ?)"
    if db_type == "postgres":
        cur.execute(sql_ins, (name, user_id))
        pid = int(cur.fetchone()[0])
    else:
        cur.execute(sql_ins, (name, user_id))
        cur.execute("SELECT last_insert_rowid()")
        pid = int(cur.fetchone()[0])
    conn.commit()
    return pid


def _save_preset_from_basket(conn, db_type: str, preset_name: str, user_id: int, basket: Basket):
    """
    Map basket -> preset_items via produkt name + section -> IDs.
    """
    _ensure_preset_tables(conn, db_type)
    preset_id = _find_or_create_preset(conn, db_type, preset_name, user_id)

    cur = conn.cursor()
    # Clear existing items for this preset (so saving again overwrites cleanly)
    sql_del = "DELETE FROM preset_items WHERE preset_id = %s" if db_type == "postgres" else \
              "DELETE FROM preset_items WHERE preset_id = ?"
    cur.execute(sql_del, (preset_id,))

    rows = []
    for section_name, products in basket.items.items():
        sid = _resolve_section_id(conn, db_type, section_name) or _resolve_section_id(conn, db_type, "Uncategorized")
        if sid is None:
            # If section not found, try to fallback to any existing section id
            # or create a fake one (for Postgres you'd normally add it; we skip here)
            continue
        for produkt_name, info in products.items():
            pid = _resolve_product_id(conn, db_type, produkt_name)
            if pid is None:
                # Product no longer exists in DB; skip it
                continue
            rows.append((
                preset_id,
                pid,
                sid,
                int(info.pocet_materialu),
                int(info.pocet_prace),
            ))

    if rows:
        ph = ",".join(("%s" if db_type == "postgres" else "?") for _ in range(5))
        sql_ins = f"""
            INSERT INTO preset_items
              (preset_id, product_id, section_id, pocet_materialu, pocet_prace)
            VALUES ({ph})
            """
        cur.executemany(sql_ins, rows)
    conn.commit()
    return preset_id


def show_presets_window():
    """
    Preset Builder: behaves like the normal GUI‚Äôs left DB browser + right basket,
    but the primary action is 'Save as preset'.
    """
    conn, db_type = get_database_connection()
    cursor = conn.cursor()

    # ‚îÄ‚îÄ Window scaffold
    style = tb.Style(theme="litera")
    win = tk.Toplevel()
    if isinstance(win, tk.Toplevel):
        win.transient()
    win.title("üì¶ Preset Builder")
    win.title("üì¶ Preset Builder")
    try:
        win.state("zoomed")
    except Exception:
        try:
            win.geometry("1100x700")
        except Exception:
            pass

    # ‚îÄ‚îÄ Layout: left (DB), right (basket)
    root = win
    root.grid_rowconfigure(0, weight=1)
    root.grid_columnconfigure(0, weight=1)
    root.grid_columnconfigure(1, weight=1)

    # Left panel: DB filter + results
    left = tb.Frame(root, padding=8)
    left.grid(row=0, column=0, sticky="nsew")

    # Right panel: Basket
    right = tb.Frame(root, padding=8)
    right.grid(row=0, column=1, sticky="nsew")

    # ‚îÄ‚îÄ Filters (reuse your helper)
    def refresh_db():
        try:
            apply_filters(cursor, db_type, table_vars, category_vars, name_entry, db_tree)
        except Exception as e:
            messagebox.showerror("Chyba", str(e))

    filter_container, filter_frame, setup_cat_tree, category_vars, table_vars = create_filter_panel(
        left, lambda: refresh_db()
    )
    filter_container.pack(fill="x", padx=6, pady=(0, 6))

    # Build category tree from DB
    category_structure = {}
    try:
        cursor.execute("SELECT id, hlavna_kategoria, nazov_tabulky FROM class")
        for cid, main_cat, tablename in cursor.fetchall():
            category_structure.setdefault(main_cat, []).append((cid, tablename))
    except Exception:
        pass
    setup_cat_tree(category_structure)

    # Search + controls
    top = tb.Frame(left)
    top.pack(fill="x", pady=(6, 6))
    tk.Label(top, text="Vyhƒæad√°vanie:").pack(side="left", padx=(4, 6))
    name_entry = tk.Entry(top, width=32)
    name_entry.pack(side="left")
    name_entry.bind("<KeyRelease>", lambda e: root.after(200, refresh_db))
    tb.Button(top, text="Obnovi≈•", bootstyle="secondary", command=refresh_db).pack(side="left", padx=6)

    # DB results tree
    cols = (
        "produkt", "jednotky", "dodavatel", "odkaz",
        "koeficient_material", "nakup_materialu", "cena_prace", "koeficient_prace"
    )
    db_tree = ttk.Treeview(left, columns=cols, show="headings", selectmode="extended")
    for c in cols:
        db_tree.heading(c, text=c.capitalize())
        db_tree.column(c, anchor="center", stretch=True)
    ysb = ttk.Scrollbar(left, orient="vertical", command=db_tree.yview)
    xsb = ttk.Scrollbar(left, orient="horizontal", command=db_tree.xview)
    db_tree.configure(yscrollcommand=ysb.set, xscrollcommand=xsb.set)
    db_tree.pack(fill="both", expand=True)
    ysb.pack(side="right", fill="y")
    xsb.pack(side="bottom", fill="x")

    # ‚îÄ‚îÄ Basket
    basket = Basket()
    right_top = tb.Frame(right)
    right_top.pack(fill="x")
    total_spolu_var = tk.StringVar(value="Spolu: 0.00 ‚Ç¨")
    total_praca_var = tk.StringVar(value="Spolu pr√°ca: 0.00 ‚Ç¨")
    total_material_var = tk.StringVar(value="Spolu materi√°l: 0.00 ‚Ç¨")

    tk.Label(right_top, textvariable=total_material_var).pack(side="left", padx=6)
    tk.Label(right_top, textvariable=total_praca_var).pack(side="left", padx=12)
    tk.Label(right_top, textvariable=total_spolu_var, font=("Segoe UI", 10, "bold")).pack(side="right", padx=6)

    basket_cols = (
        "produkt","jednotky","pocet_mat","k_mat","nakup_mat",
        "predaj_mat_jedn","nakup_mat_spolu","predaj_mat_spolu","zisk_mat","marza_mat",
        "pocet_pr","k_pr","cena_pr","nakup_pr_spolu","predaj_pr_jedn","predaj_pr_spolu",
        "zisk_pr","marza_pr","predaj_spolu","sync"
    )
    basket_tree = ttk.Treeview(right, columns=basket_cols, show="tree headings", selectmode="extended")
    for c in basket_cols:
        basket_tree.heading(c, text=c)
        basket_tree.column(c, anchor="center", stretch=True)
    ysb2 = ttk.Scrollbar(right, orient="vertical", command=basket_tree.yview)
    xsb2 = ttk.Scrollbar(right, orient="horizontal", command=basket_tree.xview)
    basket_tree.configure(yscrollcommand=ysb2.set, xscrollcommand=xsb2.set)
    basket_tree.pack(fill="both", expand=True, pady=(6, 6))
    ysb2.pack(side="right", fill="y")
    xsb2.pack(side="bottom", fill="x")

    # Add to basket from DB selection
    def add_selected_to_basket():
        sel = db_tree.selection()
        if not sel:
            messagebox.showwarning("V√Ωber", "Najprv vyber polo≈æky v datab√°ze.")
            return

        def mark_modified():
            # nothing special for builder; totals recomputed anyway
            pass

        for iid in sel:
            vals = db_tree.item(iid).get("values")
            if not vals:
                continue
            # values already shaped for add_to_basket_full; inject section from header tag if present
            section = None
            tags = db_tree.item(iid, "tags") or ()
            if "header" in tags:
                continue
            # Your apply_filters puts the section name as the 9th value in tree when building cards,
            # but here we just default to "Uncategorized". User can drag later if needed.
            item = tuple(vals[:8]) + (None,)
            add_to_basket_full(item, basket, conn, cursor, db_type, basket_tree,
                               mark_modified, total_spolu_var, None, total_material_var)
        # Update totals
        recompute_total_spolu(basket, total_spolu_var, None, total_material_var)

    tb.Button(left, text="Prida≈• do ko≈°√≠ka", bootstyle="success", command=add_selected_to_basket).pack(fill="x", pady=(6, 10), padx=2)

    # Initial load
    refresh_db()

    # ‚îÄ‚îÄ Save as preset
    def save_as_preset():
        if not basket.items:
            messagebox.showinfo("Info", "Ko≈°√≠k je pr√°zdny.")
            return

        name = simpledialog.askstring("Preset", "N√°zov presetu:")
        if not (name and name.strip()):
            return

        uid = _load_logged_in_user_id(conn, db_type)
        if uid is None:
            messagebox.showerror("Chyba", "Neviem urƒçi≈• user_id.")
            return

        try:
            pid = _save_preset_from_basket(conn, db_type, name.strip(), uid, basket)
            messagebox.showinfo("OK", f"Preset '{name}' ulo≈æen√Ω (ID {pid}).")
        except Exception as e:
            messagebox.showerror("Chyba", f"Nepodarilo sa ulo≈æi≈• preset:\n{e}")

    btn_bar = tb.Frame(right)
    btn_bar.pack(fill="x")
    tb.Button(btn_bar, text="Ulo≈æi≈• ako preset", bootstyle="primary", command=save_as_preset).pack(side="left", padx=4, pady=4)
    tb.Button(btn_bar, text="Zavrie≈•", bootstyle="secondary", command=win.destroy).pack(side="right", padx=4, pady=4)
